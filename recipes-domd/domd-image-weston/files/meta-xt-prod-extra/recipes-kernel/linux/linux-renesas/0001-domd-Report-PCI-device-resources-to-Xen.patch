From bf3434bbc7e817afac64c8f07bf682e9ec04a24d Mon Sep 17 00:00:00 2001
From: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
Date: Tue, 20 Oct 2020 11:37:37 +0300
Subject: [PATCH] domd: Report PCI device resources to Xen
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When PHYSDEVOP_pci_device_add is called there are no resources assigned
to a PCI device yet: this happens in DomD kernel’s  PCI bus notifier
during enumeration yet before the resources are assigned.
So, it is not possible to use this OP to pass IOMEM/IRQs to Xen.
Add PHYSDEVOP_pci_device_resources hypercall to pass PCI device resources
for that purpose. Pass PCI device resources from Linux kernel’s during
device_initcall_sync init step: this seems to be the right time for that
as when the PCI enumeration notifier callback is called the relevant
PCI devices are not yet assigned their resources, so notifiers cannot be used.

Signed-off-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
---
 drivers/xen/pci.c               | 87 +++++++++++++++++++++++++++++++++
 include/xen/interface/physdev.h | 34 +++++++++++++
 2 files changed, 121 insertions(+)

diff --git a/drivers/xen/pci.c b/drivers/xen/pci.c
index 5294af8665e2..8e857c9c43e3 100644
--- a/drivers/xen/pci.c
+++ b/drivers/xen/pci.c
@@ -33,6 +33,67 @@
 
 static bool __read_mostly pci_seg_supported = true;
 
+#ifdef CONFIG_ARM64
+static int xen_print_driver_resources(struct device *dev)
+{
+	int i;
+	resource_size_t start, end;
+	unsigned long flags;
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	dev_info(dev, "-- IRQ %d\n", pdev->irq);
+	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+		flags = pci_resource_flags(pdev, i);
+
+		if ((flags & (IORESOURCE_IO | IORESOURCE_MEM)) == 0)
+			continue;
+
+		start = pci_resource_start(pdev, i);
+		end  = pci_resource_end(pdev, i);
+
+		if (!start || !end)
+			continue;
+	}
+	return 0;
+}
+
+static int xen_report_resources(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct physdev_pci_device_resources res;
+	int i, j;
+
+	memset(&res, 0, sizeof(res));
+
+	res.seg = pci_domain_nr(pci_dev->bus);
+	res.bus = pci_dev->bus->number;
+	res.devfn = pci_dev->devfn;
+	res.irq = pci_dev->irq;
+	j = 0;
+	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+		resource_size_t start, end;
+		unsigned long flags;
+
+		flags = pci_resource_flags(pci_dev, i);
+
+		if ((flags & (IORESOURCE_IO | IORESOURCE_MEM)) == 0)
+			continue;
+
+		start = pci_resource_start(pci_dev, i);
+		end  = pci_resource_end(pci_dev, i);
+
+		if (!start || !end)
+			continue;
+
+		res.resource[j].flags = flags;
+		res.resource[j].start = start;
+		res.resource[j].length = pci_resource_len(pci_dev, i);
+		j++;
+	}
+	return HYPERVISOR_physdev_op(PHYSDEVOP_pci_device_set_resources, &res);
+}
+#endif
+
 static int xen_add_device(struct device *dev)
 {
 	int r;
@@ -184,6 +245,10 @@ static int xen_pci_notifier(struct notifier_block *nb,
 	switch (action) {
 	case BUS_NOTIFY_ADD_DEVICE:
 		r = xen_add_device(dev);
+#ifdef CONFIG_ARM64
+		xen_print_driver_resources(dev);
+		r = xen_report_resources(dev);
+#endif
 		break;
 	case BUS_NOTIFY_DEL_DEVICE:
 		r = xen_remove_device(dev);
@@ -259,3 +324,25 @@ static int __init xen_mcfg_late(void)
  */
 subsys_initcall_sync(xen_mcfg_late);
 #endif
+
+#ifdef CONFIG_ARM64
+static int __init xen_report_resources_all(void)
+{
+	struct pci_dev *pdev = NULL;
+
+	printk("Reporting PCI resources to Xen\n");
+	while ((pdev = pci_get_subsys(PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+				      PCI_ANY_ID, pdev)) != NULL) {
+		int r;
+
+		xen_print_driver_resources(&pdev->dev);
+
+		r = xen_report_resources(&pdev->dev);
+
+		if (r && (r != -ENOSYS))
+			return r;
+	}
+	return 0;
+}
+device_initcall_sync(xen_report_resources_all);
+#endif
diff --git a/include/xen/interface/physdev.h b/include/xen/interface/physdev.h
index 610dba9b620a..4b5b62ac44ed 100644
--- a/include/xen/interface/physdev.h
+++ b/include/xen/interface/physdev.h
@@ -297,6 +297,40 @@ struct physdev_dbgp_op {
     } u;
 };
 
+#define PHYSDEVOP_pci_device_set_resources  32
+/*
+ * PCI resources are:
+ * #0-5: standard PCI resources
+ * #6: expansion ROM resource
+ * TODO: SR-IOV
+ */
+#define PHYSDEV_PCI_NUM_RESOURCES       7
+struct physdev_pci_device_resources {
+    /* IN */
+    uint16_t seg;
+    uint8_t bus;
+    uint8_t devfn;
+    /* TODO: will we need physfn for SR-IOV devices?
+    uint32_t flags;
+    struct {
+        uint8_t bus;
+        uint8_t devfn;
+    } physfn;
+    */
+    /*
+     * FIXME: this can only be determined if the driver is up
+     * and running, e.g. in its .open callback it calls
+     * request_irq. This is true for both legacy INTx and MSI/MSI-X
+     * interrupts.
+     */
+    uint32_t irq;
+    struct {
+        uint64_t start;
+        uint64_t length;
+        uint64_t flags;
+    } resource[PHYSDEV_PCI_NUM_RESOURCES];
+};
+
 /*
  * Notify that some PIRQ-bound event channels have been unmasked.
  * ** This command is obsolete since interface version 0x00030202 and is **
-- 
2.17.1

